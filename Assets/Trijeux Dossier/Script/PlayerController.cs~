// Script by : Trijeux
// Porject : PJPJam

using System;
using System.Collections;
using Unity.Cinemachine;
using UnityEngine;
using UnityEngine.InputSystem;
using UnityEngine.Serialization;

public class PlayerController : MonoBehaviour
{
    #region Attributs

    private Rigidbody2D _rb;
    private CheckGround _checkGround;
    private EagleView2 _eagleView2;

    [Header("Player Settings")] [SerializeField]
    private float jumpForce = 10f;

    [SerializeField] private float speed = 10f;
    [SerializeField] private float runSpeed = 20f;
    [SerializeField] private float dashForce = 15f;
    [SerializeField] private float dashDuration = 0.1f;
    [SerializeField] private float coolDownDash = 1.5f;
    [SerializeField] private float spectSpeed = 1.5f;
    [SerializeField] private float spectLimitX = 5f;
    [SerializeField] private float spectLimitY = 5f;

    [Header("Object Settings")] [SerializeField]
    private GameObject specte;
    private Rigidbody2D specteRb;
    [SerializeField] CinemachineCamera mainCam;
    [SerializeField] CinemachineCamera spectCam;

    [Header("Timer Settings")] [SerializeField]
    private float doubleTapTime = 0.25f;
    [SerializeField] private float coyoteTime = 0.1f;
    
    [Header("Power")]
    [SerializeField] private bool JumpPower = false;
    [SerializeField] private bool RunPower = false;
    [SerializeField] private bool VisionPower = false;
    [SerializeField] private bool SpectralPower = false;
    [SerializeField] private bool DoubleJumpPower = false;
    [SerializeField] private bool DashPower = false;
    
    
    private float _inputLeftRight;
    private bool _inputDash;
    private bool _inputJump;
    private bool _isRunning = false;
    private Vector2 _inputCamMove = Vector2.zero;
    private float _lastTapTime = 0f;
    private int _lastTapDirection = 0;
    private bool _isCoyote = false;
    private bool _isJumping = false;
    private bool _readyToDoubleJump = false;
    private bool _isDoubleJump = false;
    private bool _isDashing = false;
    private float _dashTimer = 0f;
    private bool _isRunDash = false;
    private bool _inputSpectralMode = false;
    
    #endregion

    #region Methods

    private void SpecrtMove()
    {
        if (specte.transform.localPosition.x > spectLimitX)
        {
            specteRb.linearVelocity = Vector2.zero;
            specte.transform.localPosition = new Vector3(spectLimitX - 0.2f , specte.transform.localPosition.y);
        }
        if (specte.transform.localPosition.x < -spectLimitX)
        {
            specteRb.linearVelocity = Vector2.zero;
            specte.transform.localPosition = new Vector3(-spectLimitX + 0.2f, specte.transform.localPosition.y);
        }
        if (specte.transform.localPosition.y > spectLimitY)
        {
            specteRb.linearVelocity = Vector2.zero;
            specte.transform.localPosition = new Vector3(specte.transform.localPosition.x, spectLimitY - 0.2f);
        }
        if (specte.transform.localPosition.y < -spectLimitY)
        {
            specteRb.linearVelocity = Vector2.zero;
            specte.transform.localPosition = new Vector3(specte.transform.localPosition.x, -spectLimitY + 0.2f);
        }

        specteRb.linearVelocity = new Vector2(spectSpeed * _inputCamMove.x, spectSpeed * _inputCamMove.y);
    }

    private void Move()
    {
        _rb.linearVelocity = new Vector2(speed * _inputLeftRight, _rb.linearVelocity.y);
    }

    private void Run()
    {
        _rb.linearVelocity = new Vector2(runSpeed * _inputLeftRight, _rb.linearVelocity.y);
        if (_inputLeftRight == 0)
        {
            _isRunning = false;
        }
    }

    private void Jump()
    {
        if (_inputJump)
        {
            _rb.linearVelocityY = 0f;
            _rb.AddForce(new Vector2(0f, jumpForce), ForceMode2D.Impulse);
        }
    }

    private void CheckDoubleTap(int direction)
    {
        float currentTime = Time.time;

        if (direction == _lastTapDirection && (currentTime - _lastTapTime) <= doubleTapTime)
        {
            _isRunning = true;
            _lastTapTime = 0f;
        }
        else
        {
            _lastTapDirection = direction;
            _lastTapTime = currentTime;
        }
    }

    private void Dash(int direction)
    {
        if (_isDashing) return;

        _isDashing = true;
        _isRunning = false;
        _isRunDash = true;
        _rb.linearVelocity = Vector2.zero;
        Vector2 dashVector = new Vector2(direction * dashForce, 0f);
        _rb.AddForce(dashVector, ForceMode2D.Impulse);

        Invoke(nameof(StopDash), dashDuration);
    }

    private void StopDash()
    {
        _rb.linearVelocity = Vector2.zero;
        _isRunDash = false;
    }

    #endregion

    #region InputSystem

    private void OnRightLeft(InputValue value)
    {
        float inputLeftRight = value.Get<float>();

        if (inputLeftRight != 0 && !_isRunning)
        {
            CheckDoubleTap((int)Mathf.Sign(inputLeftRight));
        }

        _inputLeftRight = inputLeftRight;
    }

    private void OnDash(InputValue value)
    {
        _inputDash = value.isPressed;
    }

    private void OnJump(InputValue value)
    {
        _inputJump = value.isPressed;
    }

    private void OnCamMove(InputValue value)
    {
        _inputCamMove = value.Get<Vector2>();
    }

    private void OnSpectralMode(InputValue value)
    {
        _inputSpectralMode = value.isPressed;
    }
    
    #endregion

    #region Behaviors

    private void Start()
    {
        _rb = GetComponent<Rigidbody2D>();
        _checkGround = GetComponentInChildren<CheckGround>();
        specteRb = specte.GetComponent<Rigidbody2D>();
        _eagleView2 = GetComponent<EagleView2>();
    }

    private void Update()
    {
        if (!_inputSpectralMode)
        {
            switch (_checkGround.IsGrounded)
            {
                case true:
                    _isJumping = false;
                    _isDoubleJump = false;
                    _readyToDoubleJump = false;
                    break;
                case false when !_isJumping:
                    _isCoyote = true;
                    StartCoroutine(CoyoteTime());
                    break;
            }

            // Le joueur doit relâcher la touche après le premier saut pour préparer un double jump
            if (_isJumping && !_inputJump && !_isDoubleJump)
            {
                _readyToDoubleJump = true;
            }
        }

        switch (_inputSpectralMode)
        {
            case false:
                mainCam.Priority = 1;
                spectCam.Priority = 0;
                break;
            case true:
                mainCam.Priority = 0;
                spectCam.Priority = 1;
                break;
        }

        if (VisionPower)
        {
            _eagleView2.enabled = true;
        }
    }


    private void FixedUpdate()
    {
        if (!_inputSpectralMode)
        {
            if (!_isRunDash)
            {
                if (_isRunning && RunPower)
                    Run();
                else
                    Move();

                // Premier saut (sol ou coyote)
                if ((_checkGround.IsGrounded || _isCoyote) && _inputJump && !_isJumping && JumpPower)
                {
                    Jump();
                    _isJumping = true;
                    _isCoyote = false;
                }

                // Double saut (uniquement après avoir sauté une fois et avoir relâché la touche)
                if (_readyToDoubleJump && _inputJump && !_isDoubleJump && DoubleJumpPower)
                {
                    Jump();
                    _isDoubleJump = true;
                    _readyToDoubleJump = false;
                }
            }

            if (_inputDash && !_isDashing && DashPower)
            {
                Dash((int)Mathf.Sign(_inputLeftRight));
            }

            if (_isDashing)
            {
                _dashTimer += Time.deltaTime;
                if (_dashTimer >= coolDownDash)
                {
                    _dashTimer = 0f;
                    _isDashing = false;
                }
            }
            
            specte.transform.localPosition = new Vector3(0,0);
        }
        else if (_inputSpectralMode && SpectralPower)
        {
            SpecrtMove();
        }
    }


    private IEnumerator CoyoteTime()
    {
        yield return new WaitForSeconds(coyoteTime);
        _isCoyote = false; // juste ça
    }

    #endregion
}
